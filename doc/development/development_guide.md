# Developer Documentation for Git Enhancer

This document provides information for developers working on or contributing to the `gitie` project.

## Project Structure

The project follows a modular Rust project layout:

```
gitie/
├── .git/                  # Git repository data
├── .gitignore             # Specifies intentionally untracked files
├── Cargo.toml             # The manifest file for Rust, defining project metadata and dependencies
├── Cargo.lock             # Records exact versions of dependencies
├── assets/                # Directory for AI prompts and config examples
│   ├── commit-message-generator.md  # System prompt for generating commit messages
│   ├── git-ai-helper.md   # System prompt for command explanations
│   ├── expert-prompt.md   # System prompt for Git error explanations
│   ├── commit-syntax.md   # System prompt for commit syntax validation
│   └── config.example.toml # Example configuration for AI settings
├── src/                   # Source code
│   ├── main.rs            # Main application entry point 
│   ├── lib.rs             # Library entry point for exposing modules
│   ├── ai_module/         # AI-related functionality
│   │   ├── mod.rs         # Module definitions
│   │   ├── explainer.rs   # AI explanation features
│   │   └── utils.rs       # AI utility functions
│   ├── cli_interface/     # Command-line interface functionality
│   │   ├── mod.rs         # Module definitions
│   │   ├── args.rs        # Command-line argument parsing (Clap structs)
│   │   └── ui.rs          # User interface helpers
│   ├── command_processing/ # Command handling functionality
│   │   ├── mod.rs         # Module definitions
│   │   └── commit.rs      # Commit command handling
│   ├── config_management/ # Configuration handling
│   │   ├── mod.rs         # Module definitions
│   │   └── settings.rs    # Configuration loading (config.toml, prompts)
│   ├── core/              # Core functionality
│   │   ├── mod.rs         # Module definitions
│   │   ├── errors.rs      # Custom error types
│   │   └── types.rs       # Common type definitions
│   ├── git_module/        # Git interaction functionality
│   │   ├── mod.rs         # Module definitions for Git operations
│   │   └── ...            # Additional Git-related modules
│   └── tree_sitter_analyzer/ # Tree-sitter code analysis 
│       ├── mod.rs         # Module definitions
│       ├── analyzer.rs    # Analysis logic
│       ├── core.rs        # Core data structures
│       ├── java.rs        # Java language support
│       └── rust.rs        # Rust language support
├── tests/                 # Integration tests
│   ├── cli_args_test.rs   # Tests for command-line argument parsing
│   ├── default_ai_behavior_test.rs # Tests for AI behavior
│   └── tree_sitter_tests.rs # Tests for Tree-sitter functionality
├── doc/                   # Documentation files
│   └── development/       # Developer documentation
│       ├── README.md      # Developer README
│       ├── development_guide.md # This file
│       └── quickstart.md  # Quick start guide
├── target/                # Build artifacts (generated by Cargo)
└── README.md              # Main project README with user documentation
```

### Core Modules

*   **Main Application**
    *   `main.rs`:
        *   Initializes logging (`tracing`).
        *   Sets up the Tokio runtime for asynchronous operations.
        *   Handles command-line arguments.
        *   Delegates to command handlers.
        *   Handles top-level error reporting.
    *   `lib.rs`:
        *   Exposes modules for library use and testing.
        *   Re-exports key components.

*   **Command Line Interface**
    *   `cli_interface/args.rs`:
        *   Defines command-line argument structures using `clap::Parser`.
        *   Specifies subcommands (e.g., `commit`) and their respective arguments.
        *   Provides utility functions for argument parsing.
    *   `cli_interface/ui.rs`:
        *   Contains UI-related functionality.

*   **Command Processing**
    *   `command_processing/commit.rs`:
        *   Handles the commit command workflow.
        *   Integrates with AI for generating commit messages.
        *   Processes command options.

*   **Configuration Management**
    *   `config_management/settings.rs`:
        *   Defines the `AppConfig` struct to hold runtime configuration.
        *   Handles loading settings from `config.toml` (API URL, model, temperature, API key).
        *   Handles loading system prompts from the `assets` directory.
        *   Provides default values if configuration is missing or incomplete.

*   **AI Module**
    *   `ai_module/utils.rs`:
        *   Contains utilities for AI request/response handling.
        *   Provides tools for cleaning and formatting AI outputs.
    *   `ai_module/explainer.rs`:
        *   Handles AI-based explanation of Git commands and errors.
        *   Formats prompts and processes responses.

*   **Core**
    *   `core/errors.rs`:
        *   Defines the main `AppError` enum, which aggregates various error types.
        *   Defines specific error enums: `ConfigError`, `GitError`, `AIError`.
        *   Implements error traits and conversion functions.
    *   `core/types.rs`:
        *   Defines common types used throughout the application.

*   **Git Module**
    *   `git_module/mod.rs`:
        *   Provides functions for executing Git commands.
        *   Handles Git command output and error processing.

*   **Tree-Sitter Analyzer**
    *   `tree_sitter_analyzer/analyzer.rs`:
        *   Main Tree-sitter analysis functionality.
        *   Parses and analyzes code structure.
    *   `tree_sitter_analyzer/core.rs`:
        *   Core data structures for code analysis.
    *   Language-specific modules (`java.rs`, `rust.rs`):
        *   Language-specific parsing and analysis.

## Development Workflow

1.  **Clone the Repository**:
    ```bash
    git clone <repository_url>
    cd gitie
    ```

2.  **Build**:
    *   Debug build: `cargo build`
    *   Release build: `cargo build --release`

3.  **Run**:
    After building, the executable is at `target/debug/gitie` or `target/release/gitie`.
    ```bash
    ./target/debug/gitie commit --ai
    ```
    It's often useful to have a `config.json` (copied from `config.example.json`) and `prompts/commit-prompt` in the project root when testing locally.

4.  **Format Code**:
    Ensure your code is formatted according to Rust conventions:
    ```bash
    cargo fmt
    ```

5.  **Lint Code**:
    Check for common mistakes and style issues:
    ```bash
    cargo clippy --all-targets --all-features -- -D warnings
    ```
## Testing

6.  **Testing**:
    The project includes both unit tests and integration tests.
    ```bash
    # Run all tests
    cargo test
    
    # Run specific test file
    cargo test --test cli_args_test
    
    # Run tests with specific features
    cargo test -- --skip-ignored  # Skip tests marked with #[ignore]
    ```
    
    The test suite includes:
    * Unit tests within each module
    * Integration tests in the `tests/` directory
    * Tests for CLI argument handling
    * Tests for AI behavior
    * Tests for Tree-sitter code analysis

## Key Design Decisions & Future Considerations

*   **Error Handling**: Centralized in `errors.rs` using custom error types. Aims to provide clear, actionable error messages.
*   **Configuration**: Separated from code into `config.json` and `prompts/` directory to allow users to customize AI behavior without modifying the source.
*   **Modularity**: Code is broken down into modules (`cli`, `config`, `ai_utils`, `errors`) for better organization and maintainability.
*   **Asynchronous Operations**: Uses `tokio` for non-blocking I/O, especially for network requests to the AI API and running external Git commands.

### Potential Future Enhancements / Areas for Contribution

*   **Expanding Test Coverage**:
    *   More comprehensive unit tests.
    *   Additional integration tests with mocked AI services.
    *   Performance testing for code analysis features.
*   **More AI Features**:
    *   AI-assisted `git add` (suggesting files to stage).
    *   AI-assisted `git rebase -i` (suggesting reorderings or squashes).
    *   Branch name generation.
    *   Enhanced Tree-sitter code analysis integration with AI for better commit suggestions.
*   **Improved Configuration Management**:
    *   Support for system-wide or user-global configuration (e.g., in `~/.config/gitie/`).
    *   Environment variable overrides for configuration settings.
    *   Persistent storage of user preferences.
*   **Enhanced AI Interaction**:
    *   Support for different LLM providers/APIs beyond OpenAI-compatible ones.
    *   More sophisticated prompt engineering.
    *   Allowing users to easily manage multiple prompt templates.
    *   Fine-tuning AI responses for specific programming languages or project types.
*   **Better Git Integration**:
    *   Installing as a Git alias more easily.
    *   Using a Git library (like `git2-rs`) instead of shell commands for some operations, which could improve robustness and performance, but adds complexity.
    *   Integration with Git hooks for automated workflows.
*   **Streaming AI Responses**: For models that support streaming, this could provide faster feedback to the user.
*   **Installation and Packaging**: Create installers or packages for different operating systems (e.g., using `cargo-deb` for Debian packages, Homebrew formula for macOS).
*   **Language Support**: Expand Tree-sitter language support for more programming languages beyond Rust, Java, Python, and Go.

## Contribution Guidelines

1.  **Fork the repository.**
2.  **Create a new branch** for your feature or bug fix: `git checkout -b feature/your-feature-name` or `git checkout -b fix/your-bug-fix`.
3.  **Make your changes.**
4.  **Ensure your code is formatted (`cargo fmt`) and passes linter checks (`cargo clippy`).**
5.  **Add tests** for your changes if applicable.
6.  **Commit your changes** with clear, descriptive commit messages.
7.  **Push your branch** to your fork: `git push origin feature/your-feature-name`.
8.  **Open a Pull Request** against the main repository.

Please provide a clear description of your changes in the Pull Request.

## Code Style

*   Follow standard Rust idioms and conventions.
*   Use `rustfmt` for code formatting.
*   Adhere to `clippy` recommendations.
*   Write clear and concise comments where necessary.

## Logging with `tracing`

*   **The project uses the `tracing` crate for logging.**
*   Use `tracing::info!`, `tracing::warn!`, `tracing::error!`, `tracing::debug!`, `tracing::trace!` macros for logging events.
*   Log output can be controlled via the `RUST_LOG` environment variable (e.g., `RUST_LOG=gitie=debug,warn`).

Example:
```rust
use tracing::{info, error};

fn my_function() -> Result<(), String> {
    info!("Starting my_function");
    // ... do something ...
    if an_error_occurred {
        error!("An error occurred: {}", error_details);
        return Err("Something went wrong".to_string());
    }
    info!("my_function completed successfully");
    Ok(())
}
```