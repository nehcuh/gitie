# Developer Documentation for Git Enhancer

This document provides information for developers working on or contributing to the `gitie` project.

## Project Structure

The project follows a standard Rust project layout:

```
gitie/
├── .git/                  # Git repository data
├── .gitignore             # Specifies intentionally untracked files
├── Cargo.toml             # The manifest file for Rust, defining project metadata and dependencies
├── Cargo.lock             # Records exact versions of dependencies
├── config.example.json    # Example configuration for AI settings
├── prompts/               # Directory for AI prompts
│   └── commit-prompt      # System prompt for generating commit messages
├── src/                   # Source code
│   ├── main.rs            # Main application entry point, argument parsing, and orchestration
│   ├── cli.rs             # Command-line interface argument parsing (Clap structs)
│   ├── config.rs          # Configuration loading (config.json, prompts)
│   ├── ai_utils.rs        # Structs and utilities for interacting with AI (OpenAI-compatible API)
│   └── errors.rs          # Custom error types for the application
├── doc/                   # Documentation files
│   └── DEVELOPMENT.md     # This file
├── target/                # Build artifacts (generated by Cargo)
└── README.md              # Main project README with user documentation
```

### Core Modules

*   `main.rs`:
    *   Initializes logging (`tracing`).
    *   Sets up the Tokio runtime for asynchronous operations.
    *   Parses command-line arguments using `clap` (definitions in `cli.rs`).
    *   Loads application configuration (AI model, API URL, prompts) via `config.rs`.
    *   Checks if the current directory is a Git repository.
    *   Delegates to command handlers (e.g., `handle_commit`).
    *   Handles top-level error reporting.
*   `cli.rs`:
    *   Defines command-line argument structures using `clap::Parser`.
    *   Specifies subcommands (e.g., `commit`) and their respective arguments (e.g., `--ai`, `-m`).
*   `config.rs`:
    *   Defines the `AppConfig` struct to hold runtime configuration.
    *   Handles loading settings from `config.json` (API URL, model, temperature, API key).
    *   Handles loading the system prompt from `prompts/commit-prompt`.
    *   Provides default values if `config.json` is missing or incomplete.
    *   Defines `ConfigError` for configuration-specific issues (though `ConfigError` itself is now in `errors.rs`).
*   `ai_utils.rs`:
    *   Contains structs for serializing requests to and deserializing responses from an OpenAI-compatible API (e.g., `OpenAIChatRequest`, `OpenAIChatCompletionResponse`).
    *   Future: May contain helper functions for constructing AI requests or processing responses if logic becomes more complex.
*   `errors.rs`:
    *   Defines the main `AppError` enum, which aggregates various error types.
    *   Defines specific error enums: `ConfigError`, `GitError`, `AIError`.
    *   Implements `std::error::Error` and `std::fmt::Display` for all custom errors.
    *   Provides `From` trait implementations for convenient error conversions (e.g., `ConfigError` into `AppError`).

## Development Workflow

1.  **Clone the Repository**:
    ```bash
    git clone <repository_url>
    cd gitie
    ```

2.  **Build**:
    *   Debug build: `cargo build`
    *   Release build: `cargo build --release`

3.  **Run**:
    After building, the executable is at `target/debug/gitie` or `target/release/gitie`.
    ```bash
    ./target/debug/gitie commit --ai
    ```
    It's often useful to have a `config.json` (copied from `config.example.json`) and `prompts/commit-prompt` in the project root when testing locally.

4.  **Format Code**:
    Ensure your code is formatted according to Rust conventions:
    ```bash
    cargo fmt
    ```

5.  **Lint Code**:
    Check for common mistakes and style issues:
    ```bash
    cargo clippy --all-targets --all-features -- -D warnings
    ```

6.  **Testing**:
    (Currently, no automated tests are implemented. This is a key area for future development.)
    When tests are added:
    ```bash
    cargo test
    ```

## Key Design Decisions & Future Considerations

*   **Error Handling**: Centralized in `errors.rs` using custom error types. Aims to provide clear, actionable error messages.
*   **Configuration**: Separated from code into `config.json` and `prompts/` directory to allow users to customize AI behavior without modifying the source.
*   **Modularity**: Code is broken down into modules (`cli`, `config`, `ai_utils`, `errors`) for better organization and maintainability.
*   **Asynchronous Operations**: Uses `tokio` for non-blocking I/O, especially for network requests to the AI API and running external Git commands.

### Potential Future Enhancements / Areas for Contribution

*   **Automated Tests**:
    *   Unit tests for individual functions (e.g., config loading, prompt formatting).
    *   Integration tests for command execution (e.g., mocking Git commands and AI responses).
*   **More AI Features**:
    *   AI-assisted `git add` (suggesting files to stage).
    *   AI-assisted `git rebase -i` (suggesting reorderings or squashes).
    *   Branch name generation.
*   **Improved Configuration Management**:
    *   Support for system-wide or user-global configuration (e.g., in `~/.config/gitie/`).
    *   Environment variable overrides for configuration settings.
*   **Enhanced AI Interaction**:
    *   Support for different LLM providers/APIs beyond OpenAI-compatible ones.
    *   More sophisticated prompt engineering.
    *   Allowing users to easily manage multiple prompt templates.
*   **Better Git Integration**:
    *   Installing as a Git alias more easily.
    *   Using a Git library (like `git2-rs`) instead of shell commands for some operations, which could improve robustness and performance, but adds complexity.
*   **Streaming AI Responses**: For models that support streaming, this could provide faster feedback to the user.
*   **Installation and Packaging**: Create installers or packages for different operating systems (e.g., using `cargo-deb` for Debian packages, Homebrew formula for macOS).

## Contribution Guidelines

1.  **Fork the repository.**
2.  **Create a new branch** for your feature or bug fix: `git checkout -b feature/your-feature-name` or `git checkout -b fix/your-bug-fix`.
3.  **Make your changes.**
4.  **Ensure your code is formatted (`cargo fmt`) and passes linter checks (`cargo clippy`).**
5.  **Add tests** for your changes if applicable.
6.  **Commit your changes** with clear, descriptive commit messages.
7.  **Push your branch** to your fork: `git push origin feature/your-feature-name`.
8.  **Open a Pull Request** against the main repository.

Please provide a clear description of your changes in the Pull Request.

## Code Style

*   Follow standard Rust idioms and conventions.
*   Use `rustfmt` for code formatting.
*   Adhere to `clippy` recommendations.
*   Write clear and concise comments where necessary.

## Logging with `tracing`

*   **The project uses the `tracing` crate for logging.**
*   Use `tracing::info!`, `tracing::warn!`, `tracing::error!`, `tracing::debug!`, `tracing::trace!` macros for logging events.
*   Log output can be controlled via the `RUST_LOG` environment variable (e.g., `RUST_LOG=gitie=debug,warn`).

Example:
```rust
use tracing::{info, error};

fn my_function() -> Result<(), String> {
    info!("Starting my_function");
    // ... do something ...
    if an_error_occurred {
        error!("An error occurred: {}", error_details);
        return Err("Something went wrong".to_string());
    }
    info!("my_function completed successfully");
    Ok(())
}
```